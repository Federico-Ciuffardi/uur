#!/usr/bin/env bash

source "/usr/lib/naylib"

EXE_NAME="uur"

NAME="Universal User Repository"

VERSION="0.1.0"

HELP_MSG="$NAME $VERSION

Usage: $EXE_NAME [<flags>] <command>

Flags:
  -v, --version  output version information and exit
  -h, --help     display this help and exit

Commands:
   list              Show the packages 
   install           Install a package
"

#########
# MISC  #
#########

## trap ctrl-c and call ctrl_c()
trap ctrl_c INT
function ctrl_c() {
        printf "\n\nAborted, exiting...\n"
        exit 127
}


function set_pkg(){
  package="$1"

  package_spec_dir="$repos_dir/$package"

  if ! [ -d $package_spec_dir ] ; then
    echo "No package \"$package\""
    exit 1
  fi

  package_version_file="$meta_dir/$package/installed_version"
  package_build_dir="$build_dir/$package"
}

function make(){
  if [ -f "$package_spec_dir/imake" ] ; then 
    sudo -v
    bash "$package_spec_dir/imake" || exit 1
  fi
  if [ -f "$package_spec_dir/make" ] ; then 
    sudo -v
    draw_spinner "Making \"$package\"" "bash "$package_spec_dir/make"" || exit 1
  fi
}

function native-install(){
  local distro_name="$1"
  local pkg="$2"
  local msg="${3:-"Installing dependency:"}"
  local package_manager=""

  case "$distro_name" in
    Arch)
      #  ||
      if pacman -Sqg "$pkg" &> /dev/null ; then
        for gpkg in `pacman -Sqg "$pkg"` ; do
          if ! pacman -Q "$gpkg" &> /dev/null ; then
            package_manager="sudo pacman -S --noconfirm --needed"
          fi
        done
      elif pacman -Ssq "$pkg" | grep "^$pkg$" &> /dev/null ; then
        if ! pacman -Q "$pkg" &> /dev/null ; then
          package_manager="sudo pacman -S --noconfirm --needed"
        fi
      elif yay -Sqg "$pkg" &> /dev/null ; then 
        for gpkg in `yay -Sqg "$pkg"` ; do
          if ! yay -Q "$gpkg" &> /dev/null ; then 
            package_manager="yay -S --noconfirm --needed"
          fi
        done
      elif yay -Ssq "$pkg" 2>/dev/null | grep "^$pkg$" &> /dev/null ; then
        if ! yay -Q "$pkg" &> /dev/null ; then
          package_manager="yay -S --noconfirm --needed"
        fi
      else
        if ! [ -f "$meta_dir/$pkg/installed_version" ] ; then
          package_manager="uur install"
        fi
      fi
      ;;
    Ubuntu)
      if apt-cache search "$pkg" | grep "^$pkg " &> /dev/null ; then
        if ! dpkg -s "$pkg" &>/dev/null ; then
          package_manager="sudo apt install -y"
        fi
      else
        if ! [ -f "$meta_dir/$package/installed_version" ] ; then
          package_manager="uur install"
        fi
      fi
      ;;
    *) 
      echo "Unsuported distro \"$distro_name\""
      exit 1
      ;;
  esac
  if [ "$package_manager" != "" ] ; then
    sudo -v
    draw_spinner "$msg $pkg" "$package_manager $pkg" || exit 1
  fi
}

function sync(){
  if [ -f $package_version_file ] ; then
    upgrade
  else
    install
  fi

}

function upgrade(){
  if ! [ -f $package_version_file ] ; then
    echo "\"$package\" not installed"
    exit 1
  fi

  echo "Upgrading package \"$package\""

  cd "$package_build_dir"

  # upgrade package
  if [ -f "$package_spec_dir/git" ] ; then
    git_url=$(head -n1 "$package_spec_dir/git")
    if [ -d git_src ] ; then 
      draw_spinner "Pulling" "git -C git_src pull" || exit 1
    fi
    new_update_id=$(git -C git_src rev-parse HEAD)
  elif [ -f "$package_spec_dir/ver" ] ; then
    new_update_id=$(cat "$package_spec_dir/ver")
  else
    new_update_id="no_id"
  fi

  if [ $new_update_id != "no_id" ] && [ "$new_update_id" = $(cat "$package_version_file") ] ; then
    echo "\"$package\" already up to date"
    exit 0
  fi

  make

  echo "$new_update_id" > "$meta_dir/$package/installed_version"

  # go back to repos_dir
  cd "$repos_dir"

}

function install(){
  if [ -f $package_version_file ] ; then
    echo "\"$package\" already installed"
    exit 0
  fi

  echo "Installing package \"$package\""

  # go to data/bin/build path
  mkdir -p "$package_build_dir"
  cd "$package_build_dir"

  # install package dependencies
  deps_file="$package_spec_dir/deps/$distro_name"
  if [ -f "$deps_file" ] ; then 
    for dep in $(cat "$deps_file") ; do
      native-install $distro_name $dep
      [ $? -eq 0 ] || exit 1
    done
  fi

  # install package
  if [ -f "$package_spec_dir/git" ] ; then
    git_url=$(head -n1 "$package_spec_dir/git")
    if ! [ -d git_src ] ; then 
      draw_spinner "Cloning" "git clone $git_url git_src" || exit 1
    fi
    update_id=$(git -C git_src rev-parse HEAD)
  else
    update_id="no_id"
  fi

  make

  mkdir -p "$meta_dir/$package"
  echo "$update_id" > "$meta_dir/$package/installed_version"

  # go back to repos_dir
  cd "$repos_dir"
}

function list_all_pkg(){
  for repo_name in $(ls) ; do
    for pkg_name in $(ls "$repo_name") ; do
      echo "$repo_name/$pkg_name"
    done
  done

}

function list(){
  cd "$repos_dir"

  if [ $# -eq 0 ] ; then
    list_all_pkg
  fi

  while [ $# -gt 0 ]; do
    case "$1" in
      -i|--installed)
        for repo_name in $(ls) ; do
          for pkg_name in $(ls "$repo_name") ; do
            version_file="$meta_dir/$repo_name/$pkg_name/installed_version"
            if [ -f "$version_file" ] ; then
              echo "$repo_name/$pkg_name"
            fi
          done
        done
        exit 0
        ;;
      -v|--versions)
        for repo_name in $(ls) ; do
          for pkg_name in $(ls "$repo_name") ; do
            version_file="$meta_dir/$repo_name/$pkg_name/installed_version"
            if [ -f "$version_file" ] ; then
              echo "$repo_name/$pkg_name : $(cat $version_file)"
            fi
          done
        done
        exit 0
        ;;
      -a|--all)
        list_all_pkg
        exit 0
        ;;
      -r|--repo)
        for repo_name in $(ls) ; do
          echo "$repo_name"
        done
        exit 0
        ;;

      -*)
        echo "'$1' is not a \"$EXE_NAME list\" flag. See '$EXE_NAME --help'."
        exit 2
        ;;
    esac
  shift
  done
}

########
# MAIN #
########
if [[ ${DEBUG-} =~ ^1|yes|true$ ]]; then
    set -o xtrace       # Trace the execution of the script (debug)
fi

set -o nounset      # Disallow expansion of unset variables
set -o pipefail     # Use last non-zero exit code in a pipeline
set -o errtrace     # Ensure the error trap handler is inherited

uur_config_dir="$HOME/.config/uur"
mkdir -p "$uur_config_dir"

uur_repos_file="$uur_config_dir/repos"
if ! [ -f $uur_repos_file ] ; then 
  echo "https://github.com/Federico-Ciuffardi/uur-repo-main" > $uur_repos_file
fi

build_dir="$HOME/.local/share/uur/builds"
mkdir -p "$build_dir"
repos_dir="$HOME/.local/share/uur/repos"
mkdir -p "$repos_dir"
meta_dir="$HOME/.local/share/uur/meta"
mkdir -p "$meta_dir"

while [ $# -gt 0 ]; do
  case "$1" in
    -h|--help)
      echo "$HELP_MSG"
      exit 0
      ;;
    -v|--version)
      echo "$NAME $VERSION"
      exit 0
      ;;
    update)
      cd "$repos_dir"
      for repo_url in $(cat $uur_repos_file) ; do
        repo_name=${repo_url##*-}
        repo_dir="$repos_dir/$repo_name"
        if [ ! -d $repo_dir ] ; then
          draw_spinner "Updating \"$repo_name\"" "git clone $repo_url" $repo_name
        else
          draw_spinner "Updating \"$repo_name\"" "git -C $repo_dir pull" 
        fi
      done
      exit 0
      ;;
    list)
      $@
      exit 0
      ;;
    install|upgrade|sync)
      distro_name=$(lsb_release -i | sed 's/.*:\s*//g')
      set_pkg $2
      $1 "$2"
      exit 0
      ;;
    native)
      distro_name=$(lsb_release -i | sed 's/.*:\s*//g')
      native-install $distro_name $2
      exit 0
      ;;
    -*)
      echo "'$1' is not a $EXE_NAME flag. See '$EXE_NAME --help'."
      exit 2
      ;;
    *)
      echo "'$1' is not a $EXE_NAME command. See '$EXE_NAME --help'."
      exit 2
      ;;
  esac
  shift
done

printf "missing command\nTry '$EXE_NAME --help' for more information.\n"
